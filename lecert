#!/bin/bash

##############################################################################
#
#
# lecert
#
# Keep it simple shell script for requesting a certificate from the Let's
# Encrypt CA using the ACME protocol.
#
# Copyright (c) 2018 Stephan Uhlmann <su@su2.info>
# Licensed under the GPL version 3, see LICENSE.txt
#
#
##############################################################################

# defaults

API="https://acme-v01.api.letsencrypt.org"
CONTACT_EMAIL=""
VERBOSE="false"
DOMAINS=()
WEBROOT=""

# stop on error
set -e
trap on_exit EXIT


##############################################################################
# functions
##############################################################################

usage()
{
	cat << EOF

Usage: lecert [options...] <domain> [ <domain> ... ]
Options:
  -e, --email EMAIL         Your email if you want that Let's Encrypt can contact you
  -h, --help                This help
  -t, --test                Use staging API of Let's Encrypt for testing the script
  -v, --verbose             Verbose mode, print additional debug output
  -w, --webroot DIRECTORY   Path to the DocumentRoot of your webserver. Can be a rsync
                            compatible remote location like www@myserver:/srv/www/htdocs/.

The first domain parameter should be your main domain name with the subdomains following after it.

Example: $0 -e me@example.com -w root@server:/var/www/example/ example.com www.example.com

EOF
}

# general log messages
log()
{
	echo "#### ${1}"
}

# debug messages
debug()
{
	if [ "${VERBOSE}" = "true" ];
	then
		# do not output to stdout, else debug output from api_request would
		# become part of the function response
		echo "${1}" >&2
	fi
}

# error messages
error()
{
	echo "ERROR: ${1}" >&2
}

# last command
on_exit()
{
	debug "EXIT ${?}"
	exit
}

# base64url encoding
# https://tools.ietf.org/html/rfc4648#section-5
# input on stdin, output on stdout
base64url()
{
	base64 -w 0 | sed 's/+/-/g' | sed 's/\//_/g' | sed 's/=*$//g'
}

# hex to binary
# input on stdin, output on stdout
hexbin()
{
	xxd -p -r
}

# remove newlines and duplicate whitespace
# input on stdin, output on stdout
flatstring()
{
	tr -d '\n\r' | sed 's/[[:space:]]\+/ /g'
}


# make and ACME API request
# $1 = URI
# $2 = body
# output on stdout
api_request()
{
	URI="${1}"
	BODY="${2}"

	# get nonce by HEAD to API
	debug "Getting nonce"
	NONCE="$(curl --silent -g --head "${API}/directory" | grep -i "^Replay-Nonce" | sed "s/Replay-Nonce: //i" | tr -d "\\r\\n")"
	debug "nonce = $NONCE"

	# JSON Web Signature
	JWS_HEADER="${JWK}"
	JWK_NONCE="{ \"alg\": \"RS256\", \"jwk\": { \"e\": \"${JWK_E}\", \"kty\": \"RSA\",\"n\": \"${JWK_N}\" }, \"nonce\": \"${NONCE}\" }"
	JWS_PROTECTED="$(printf "%s" "${JWK_NONCE}" | base64url)"
	JWS_PAYLOAD="$(printf "%s" "${BODY}" | base64url)"
	JWS_SIGNATURE="$(printf "%s" "${JWS_PROTECTED}.${JWS_PAYLOAD}" | openssl dgst -sha256 -sign "${ACCOUNT_KEY}" | base64url)"
	JWS="{ \"header\": ${JWS_HEADER}, \"protected\": \"${JWS_PROTECTED}\", \"payload\": \"${JWS_PAYLOAD}\", \"signature\": \"${JWS_SIGNATURE}\" }"

	debug "Request URI: ${URI}"
	debug "Body: ${BODY}"
	debug "JWS: ${JWS}"
	# base64 encoding/decoding necessary to stay binary safe.
	# e.g. the new-cert operation responds with a der encoded certificate.
	CURLOUT="$(curl --silent --show-error -w "\\n%{http_code}" -g -X POST -H "Content-Type: application/json" -d "${JWS}" "${URI}" | base64 -w 0 )"
	HTTP_CODE="$(echo "${CURLOUT}" | base64 -d | tail -n 1)"
	RESPONSE="$(echo "${CURLOUT}" | base64 -d | head -n -1)"
	# just in case we get a 2xx status code but an error in response body (spec is not clear on that)
	ACMEERRORCHECK="$(echo "${RESPONSE}" | flatstring | sed 's/^.*"type": "urn:acme:error.*$/ERROR/')"
	if ([ "${HTTP_CODE}" = "200" ] || [ "${HTTP_CODE}" = "201" ] || [ "${HTTP_CODE}" = "202" ]) && ([ "${ACMEERRORCHECK}" != "ERROR" ]);
	then
		debug "API request successful"
	else
		error "API request error"
		error "Request URI: ${URI}"
		error "HTTP status: ${HTTP_CODE}"
		error "${RESPONSE}"
		return 1
	fi

	# do not echo $RESPONSE but decode again from the base64 encoded curl output to stay binary safe
	# otherwise null bytes (0x00) will be lost
	echo "${CURLOUT}" | base64 -d | head -n -1
	return 0
}


##############################################################################
# main
##############################################################################


# arg handling

if [ ${#} -lt 1 ];
then
	error "Missing parameter"
	usage
	exit
fi

while [ ${#} -gt 0 ];
do
	ARG="${1}"
	case "${ARG}" in
		-e|--email)
			shift
			CONTACT_EMAIL="${1}"
			;;
		-h|--help)
			usage
			exit
			;;
		-t|--test)
			# use staging API for testing
			log "Using staging API"
			API="https://acme-staging.api.letsencrypt.org"
			;;
		-v|--verbose)
			VERBOSE="true"
			;;
		-w|--webroot)
			shift
			WEBROOT="${1}"
			;;
		*)
			X="${ARG/-*/}"
			if [ -z "${X}" ];
			then
				error "Unknown option"
				usage
				exit 1
			else
				DOMAINS[${#DOMAINS[@]}]="${ARG}"
			fi
	esac
	# shift the option flag, option flag values (if any) are shifted in case block
	shift
done

if [ ${#DOMAINS[@]} -eq 0 ];
then
	error "Domain missing"
	usage
	exit
fi

DOMAIN="${DOMAINS[0]}"

log "Creating domain subdirectory ..."
mkdir -p -- "${DOMAIN}"
log "${DOMAIN}/ created."

log "Getting URL of latest subscriber agreement ..."
AGREEMENT="$(curl --silent --head ${API}/terms | grep '^Location: ' | sed 's/^Location: //' | flatstring)"
log "${AGREEMENT}"



# we create a new account key for each certificate request
log "Generating account key ..."
ACCOUNT_KEY="${DOMAIN}/account.key"
ACCOUNT_PUB="${DOMAIN}/account.pub"
log "Private key: ${ACCOUNT_KEY}"
touch "${ACCOUNT_KEY}"
chmod 600 "${ACCOUNT_KEY}"
openssl genrsa 4096 > "${ACCOUNT_KEY}"
chmod 400 "${ACCOUNT_KEY}"
log "Public key: ${ACCOUNT_PUB}"
openssl rsa -in "${ACCOUNT_KEY}" -out "${ACCOUNT_PUB}" -pubout

# account public key exponent
# formatting: Exponent dec => hex => binary => base64url
# e.g. 65537 => 0x010001 => ... => AQAB
# printf 0.32 and cutting 00 in pairs makes sure we have even number of digits for hexbin
JWK_E="$(openssl rsa -pubin -in "${ACCOUNT_PUB}" -text -noout | grep ^Exponent | awk '{ printf "%0.32x",$2; }' | sed 's/^\(00\)*//g' | hexbin | base64url)"

# account public key modulus
JWK_N="$(openssl rsa -pubin -in "${ACCOUNT_PUB}" -modulus -noout | sed 's/^Modulus=//' | hexbin | base64url)"

# JSON Web Key
JWK="{ \"alg\": \"RS256\", \"jwk\": { \"e\": \"${JWK_E}\", \"kty\": \"RSA\", \"n\": \"${JWK_N}\" } }"
debug "jwk = ${JWK}"

# Important: no whitespaces at all. The server computes the thumbprint from our
# E and N values in JWK and does so with this exact JSON. The sha256 from us
# will not match theirs if we use a different JSON formatting.
# see example in https://tools.ietf.org/html/rfc7638
JWK_THUMBPRINT="$(printf "%s" "{\"e\":\"${JWK_E}\",\"kty\":\"RSA\",\"n\":\"${JWK_N}\"}" | openssl dgst -sha256 -binary | base64url)"
debug "jwk_thumbprint = ${JWK_THUMBPRINT}"



log "Registering account key ..."
if [ -n "${CONTACT_EMAIL}" ];
then
	REQUEST="{ \"resource\": \"new-reg\", \"contact\": [ \"mailto:${CONTACT_EMAIL}\" ], \"agreement\": \"${AGREEMENT}\" }"
else
	REQUEST="{ \"resource\": \"new-reg\", \"agreement\": \"${AGREEMENT}\" }"
fi
api_request "${API}/acme/new-reg" "${REQUEST}" > /dev/null
log "OK"



log "Generating domain private key ..."
log "Private key: ${DOMAIN}/${DOMAIN}.key"
touch "${DOMAIN}/${DOMAIN}.key"
chmod 600 "${DOMAIN}/${DOMAIN}.key"
openssl genrsa 4096 > "${DOMAIN}/${DOMAIN}.key"
chmod 400 "${DOMAIN}/${DOMAIN}.key"



log "Requesting challenges ..."
declare -a CHALLENGE_URIS
declare -a CHALLENGE_TOKENS
declare -a KEYAUTHS
for (( i=0; i < ${#DOMAINS[@]}; i++ ))
do
	REQUEST="{ \"resource\": \"new-authz\", \"identifier\": { \"type\": \"dns\", \"value\": \"${DOMAINS[$i]}\" } }"
	RESPONSE=$(api_request "${API}/acme/new-authz" "${REQUEST}")
	debug "${RESPONSE}"
	CHALLENGE_URIS[$i]="$(echo "${RESPONSE}" | flatstring | sed 's/^.*"type": "http-01", "status": "pending", "uri": "\([^"]*\)", "token": "\([^"]*\)".*$/\1/')"
	CHALLENGE_TOKENS[$i]="$(echo "${RESPONSE}" | flatstring | sed 's/^.*"type": "http-01", "status": "pending", "uri": "\([^"]*\)", "token": "\([^"]*\)".*$/\2/')"
	KEYAUTHS[$i]="${CHALLENGE_TOKENS[$i]}.${JWK_THUMBPRINT}"
	debug "${DOMAINS[$i]}     : challenge_uri=${CHALLENGE_URIS[$i]} keyauth=${KEYAUTHS[$i]}"
done
log "OK"



log "Doing HTTP validation ..."
if [ -n "${WEBROOT}" ];
then
	log "Copying challenge tokens to DocumentRoot ${WEBROOT} ..."
    (
	cd "${DOMAIN}"
	rm -rf ".well-known"
	mkdir -p ".well-known/acme-challenge"
	for (( i=0; i < ${#DOMAINS[@]}; i++ ))
	do
		echo "${KEYAUTHS[$i]}" > ".well-known/acme-challenge/${CHALLENGE_TOKENS[$i]}"
	done
	rsync -axR ".well-known/" "${WEBROOT}"
	)
else
	log "Do in your DocumentRoot:"
	echo
	echo
	echo "mkdir -p .well-known/acme-challenge"
	for (( i=0; i < ${#DOMAINS[@]}; i++ ))
	do
		echo "echo '${KEYAUTHS[$i]}' > .well-known/acme-challenge/${CHALLENGE_TOKENS[$i]}"
	done
	echo
	echo
	log "Press [Enter] when done."
	read -r
fi



log "Responding to challenges ..."
for (( i=0; i < ${#DOMAINS[@]}; i++ ))
do
	debug "${CHALLENGE_URIS[$i]}"
	REQUEST="{ \"resource\": \"challenge\", \"keyAuthorization\": \"${KEYAUTHS[$i]}\" }"
	api_request "${CHALLENGE_URIS[$i]}" "${REQUEST}" > /dev/null
done
log "OK"



log "Waiting for validation ..."
# just wait a bit until our validation files are checked by LE
sleep 5
log "Done"



log "Creating CSR ..."
export SUBJALTNAME="DNS:${DOMAINS[0]}"
for (( i=1; i < ${#DOMAINS[@]}; i++ ))
do
	export SUBJALTNAME="${SUBJALTNAME},DNS:${DOMAINS[$i]}"
done
openssl req -new -sha256 -key "${DOMAIN}/${DOMAIN}.key" -subj "/CN=${DOMAIN}" -reqexts SAN -config "$(dirname "${0}")/openssl.conf" \
 > "${DOMAIN}/${DOMAIN}.csr"
log "OK ${DOMAIN}/${DOMAIN}.csr"


log "Requesting certificate ..."
CSR="$(openssl req -in "${DOMAIN}/${DOMAIN}.csr" -inform PEM -outform DER | base64url)"
REQUEST="{ \"resource\": \"new-cert\", \"csr\": \"${CSR}\" }"
# check return status of api_request before we send the output to openssl
# needs some base64 wrapping/unwrapping to stay binary safe (cert comes der encoded)
CERT="$(api_request "${API}/acme/new-cert" "${REQUEST}" | base64 -w 0; exit "${PIPESTATUS[0]}";)"
echo "${CERT}" | base64 -d | openssl x509 -inform DER -outform PEM -out "${DOMAIN}/${DOMAIN}.crt"
log "Success! Certificate saved: ${DOMAIN}/${DOMAIN}.crt"



if [ -n "${WEBROOT}" ];
then
	log "Deleting challenge tokens in DocumentRoot ${WEBROOT} ..."
	(
	cd "${DOMAIN}" || exit
	INCLUDES=()
	for (( i=0; i < ${#DOMAINS[@]}; i++ ))
	do
		rm ".well-known/acme-challenge/${CHALLENGE_TOKENS[$i]}"
		INCLUDES+=( --include )
		INCLUDES+=( ".well-known/acme-challenge/${CHALLENGE_TOKENS[$i]}" )
	done
	rsync -axR --delete "${INCLUDES[@]}" --exclude '.well-known/acme-challenge/*' ".well-known/" "${WEBROOT}"
	)
else
	log "You can do now in your DocumentRoot:"
	echo
	echo
	echo "rm -r .well-known"
	echo
	echo
fi

log "Finished!"

